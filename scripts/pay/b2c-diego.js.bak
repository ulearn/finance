const express = require('express');
const path = require('path');
const MySQLDataProvider = require('./mysql-data');

const router = express.Router();
const dataProvider = new MySQLDataProvider();

// B2C Diego dashboard endpoint
router.get('/', async (req, res) => {
    try {
        const result = await dataProvider.getB2CData();

        if (!result.success) {
            console.error('B2C data fetch failed:', result.error);
        }

        const data = result.data || [];

        // Calculate B2C specific metrics for Diego
        const metrics = calculateB2CMetrics(data);

        res.json({
            success: result.success,
            data: data,
            metrics: metrics,
            employee: {
                name: 'Diego',
                role: 'B2C Sales Manager',
                commissionRate: '1% of total revenue',
                channel: 'B2C'
            },
            error: result.error || null
        });

    } catch (error) {
        console.error('B2C dashboard route error:', error);
        res.status(500).json({
            success: false,
            error: 'Internal server error',
            data: [],
            metrics: getEmptyB2CMetrics(),
            employee: {
                name: 'Diego',
                role: 'B2C Sales Manager',
                commissionRate: '1% of total revenue',
                channel: 'B2C'
            }
        });
    }
});

// B2C specific metrics calculation
function calculateB2CMetrics(data) {
    if (!data || data.length === 0) {
        return getEmptyB2CMetrics();
    }

    const currentMonth = new Date().toISOString().slice(0, 7); // YYYY-MM format
    const currentMonthData = data.find(d => d.month_year === currentMonth);

    // Calculate last 12 months totals
    const last12Months = data.slice(-12);

    const totalRevenue = last12Months.reduce((sum, month) => sum + (parseFloat(month.total_amount) || 0), 0);
    const totalCommissions = last12Months.reduce((sum, month) => sum + (parseFloat(month.commission_amount) || 0), 0);

    // Calculate average monthly values
    const avgMonthlyRevenue = last12Months.length > 0 ? totalRevenue / last12Months.length : 0;
    const avgMonthlyCommission = last12Months.length > 0 ? totalCommissions / last12Months.length : 0;

    // Find best and worst performing months
    const bestMonth = data.reduce((max, month) =>
        (parseFloat(month.commission_amount) || 0) > (parseFloat(max.commission_amount) || 0) ? month : max,
        data[0] || {}
    );

    const worstMonth = data.reduce((min, month) =>
        (parseFloat(month.commission_amount) || 0) < (parseFloat(min.commission_amount) || 0) ? month : min,
        data[0] || {}
    );

    // Calculate trend (comparing first 6 months vs last 6 months)
    const firstHalf = last12Months.slice(0, 6);
    const secondHalf = last12Months.slice(6);

    const firstHalfAvg = firstHalf.length > 0 ?
        firstHalf.reduce((sum, month) => sum + (parseFloat(month.commission_amount) || 0), 0) / firstHalf.length : 0;
    const secondHalfAvg = secondHalf.length > 0 ?
        secondHalf.reduce((sum, month) => sum + (parseFloat(month.commission_amount) || 0), 0) / secondHalf.length : 0;

    const trendPercent = firstHalfAvg > 0 ? ((secondHalfAvg - firstHalfAvg) / firstHalfAvg) * 100 : 0;

    return {
        currentMonth: currentMonth,
        currentMonthRevenue: parseFloat(currentMonthData?.total_amount) || 0,
        currentMonthCommission: parseFloat(currentMonthData?.commission_amount) || 0,
        currentMonthBookings: parseInt(currentMonthData?.record_count) || 0,

        last12MonthsRevenue: totalRevenue,
        last12MonthsCommissions: totalCommissions,

        avgMonthlyRevenue: avgMonthlyRevenue,
        avgMonthlyCommission: avgMonthlyCommission,

        bestMonth: {
            month: bestMonth.month_year,
            commission: parseFloat(bestMonth.commission_amount) || 0,
            revenue: parseFloat(bestMonth.total_amount) || 0
        },
        worstMonth: {
            month: worstMonth.month_year,
            commission: parseFloat(worstMonth.commission_amount) || 0,
            revenue: parseFloat(worstMonth.total_amount) || 0
        },

        trend: {
            direction: trendPercent > 0 ? 'up' : trendPercent < 0 ? 'down' : 'stable',
            percentage: Math.abs(trendPercent),
            description: trendPercent > 0 ? 'Improving' : trendPercent < 0 ? 'Declining' : 'Stable'
        },

        dataPoints: data.length,
        lastUpdated: new Date().toISOString(),
        commissionExplanation: 'Commission = 1% of total monthly revenue (all fees included)'
    };
}

function getEmptyB2CMetrics() {
    return {
        currentMonth: new Date().toISOString().slice(0, 7),
        currentMonthRevenue: 0,
        currentMonthCommission: 0,
        currentMonthBookings: 0,
        last12MonthsRevenue: 0,
        last12MonthsCommissions: 0,
        avgMonthlyRevenue: 0,
        avgMonthlyCommission: 0,
        bestMonth: { month: '', commission: 0, revenue: 0 },
        worstMonth: { month: '', commission: 0, revenue: 0 },
        trend: { direction: 'stable', percentage: 0, description: 'Stable' },
        dataPoints: 0,
        lastUpdated: new Date().toISOString(),
        commissionExplanation: 'Commission = 1% of total monthly revenue (all fees included)'
    };
}

// Cleanup function for graceful shutdown
process.on('SIGINT', async () => {
    console.log('B2C Dashboard: Closing database connections...');
    await dataProvider.disconnect();
    process.exit(0);
});

module.exports = router;